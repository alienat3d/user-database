export class UserService {
	// * 1.0 У данного класса будет 1 переменная "_users", написанная с "_", т.к. мы будем работать с ней через геттеры и сеттеры. Изначально она будет содержать пустой массив.
	// * 5.0 Создадим парочку временных объектов, которые мы сможем рендерить методом render()
	// todo upd. Больше он нам не нужен, т.к. теперь мы получаем пользователей из [../../db/db.json]
	/* 	_users = [
			{
				"id": 0,
				"name": "Al",
				"email": "psy.alienated@gmail.com",
				"children": true,
				"permissions": true
			},
			{
				"id": 1,
				"name": "Andrey",
				"email": "antr0y@yahoo.com",
				"children": true,
				"permissions": false
			}
		]; */

	// 1.1 Ну, и сразу же создадим геттер (будет получать данные) и сеттер (будет переопределять значение) для данной переменной
	// todo upd. Впрочем, как и сеттеры и геттеры больше не нужны.
	/* 	get users() {
			return this._users;
		}
	
		set users(users) {
			this._users = users;
		} */

	// * 2. Напишем тестовый метод, который будет выводить в консоль наших пользователей
	// todo upd. Да и метод logger() можно убрать
	/* 	logger() {
			console.log(this.users);
		} */

	// * 6.0 getUsers() будет возвращать результат метода fetch(). По умолчанию метод fetch() использует настройку method="GET".
	// ? 6.2 На самом деле мы могли бы просто экспортировать функцию получения данных с сервера, но тут мы разобрали на практике как пишутся реальные сервисы
	getUsers() {
		return fetch('http://localhost:3333/users')
			.then(res => res.json());
	}

	// 7.3.1 Теперь нам нужен в сервисах ещё один метод, который будет использовать "POST" для записи объекта в базу данных и который будет добавлять нового пользователя. В настройках запишем, что уже используем "POST", а также в body передаём "user", обработанный методом JSON.stringify(), ну и headers мы подсмотрим из документации к JSON-Server, нам нужны настройки: 'Content-Type': 'application/json'.
	// todo 7.3.2 Вернёмся в [add-users.js]
	// 7.4.0 Добавим и у addUsers() метод then(), чтобы переводить ответ обратно в JSON.
	// todo 7.4.1 Вернёмся в [add-users.js]
	addUser(user) {
		return fetch('http://localhost:3333/users', {
			method: 'POST',
			body: JSON.stringify(user),
			headers: {
				'Content-Type': 'application/json'
			}
		})
			.then(res => res.json());
	}

	// * 8.0 Теперь нам нужен ещё метод удаления пользователей. Для этого нам нужно отслеживать по какому именно пользователю мы кликаем. Для этого мы могли бы повесить на каждую кнопку удаления пользователя обработчик события, но лучше воспользуемся делегированием, и для этого создадим новый модуль remove-users.js
	// 8.3.1 Теперь нам только осталось в сервисах добавить метод removeUser(), который будет принимать идентификатор (key\id) и возвращать метод fetch().
	// 8.3.2 В документации к JSON-Server мы найдём, что нам нужно добавить id пользователя после запроса и "/". Ну и не забудем про конвертацию из JSON в JS-объект методом then().
	// 8.5.0 Итак, чтобы удалить, нам нужно прописать в настройках ещё специальный метод "DELETE".
	// ? 8.5.1 Метод "DELETE" создан для того, чтобы удалять целостную структуру из базы данных, т.е. один отдельный объект\сущность.
	removeUser(id) {
		return fetch(`http://localhost:3333/users/${id}`, {
			method: "DELETE"
		})
			.then(res => res.json());
	}

	// ? 9.0 Осталось рассмотреть ещё два метода работы с БД: "PUT" & "PATCH", которые между собой немного похожи, но тем не менее принципиально отличаются друг от друга.
	// ? 9.1 Метод "PUT" полностью заменяет цельную сущность в БД, а "PATCH" заменит какую-то одну часть этой сущности (значение свойства, например).
	// todo 9.2 Мы скопируем логику модуля remove-users.js и создадим/перейдём в [./change-permissions.js]
	// 9.4.1 Создадим новый метод changeUser(), который будет менять значение permissions у пользователя. Кроме id пользователя, мы будем также передавать data, а метод изменим на "PATCH".
	// 9.4.2 Как и в случае с добавлением пользователя нам нужны в настройка и body, и headers. headers останется таким же, но в body вместо пользователя целиком, мы будем передавать только часть - свойство permissions, значение которого мы изменяем.
	changeUser(id, data) {
		return fetch(`http://localhost:3333/users/${id}`, {
			method: "PATCH",
			body: JSON.stringify(data),
			headers: {
				'Content-Type': 'application/json'
			}
		})
			.then(res => res.json());
	}

	// ? 10.0 А теперь, наверное, самый сложный метод из всех — "PUT".
	// todo 10.1 Создадим для этого ещё один модуль и перейдём в него [./edit-users.js]

	// 10.1.2 В класс "UserService" нам нужно добавить два новых запроса: 1) получение информации по конкретному пользователю getUser(), который примет идентификатор "id"; 2) для сохранения новой информации о пользователе с изменёнными данными editUser(), который примет всего "user" и для надёжности также "id"
	// todo 10.2.0 Перейдём в [./edit-users.js]
	// 10.3 В getUser мы также возвращаем метод fetch() c id и запросом по умолчанию "GET".
	getUser(id) {
		return fetch(`http://localhost:3333/users/${id}`)
			.then(res => res.json());
	}
	// 10.6.0 Теперь мы опишем метод, который будет принимать id изменяемого пользователя и новый объект, которым должен быть заменён старый. По данному id будет совершаться PUT-запрос, который отправит изменённый объект пользователя и заменит им существующий в базе данных.
	// todo 10.6.1 Перейдём в [./edit-users.js]
	editUser(id, user) {
		return fetch(`http://localhost:3333/users/${id}`, {
			method: "PUT",
			body: JSON.stringify(user),
			headers: {
				'Content-Type': 'application/json'
			}
		})
			.then(res => res.json());
	}

	// * [->] 11.4.1 Теперь мы создадим метод получения фильтрованных данных filterUsers(). Мы будем после "?" передавать опции фильтрации и проверять на "true"
	// todo 11.4.2 переход [filter-users.js][->]
	filterUsers(filterOption) {
		return fetch(`http://localhost:3333/users?${filterOption}=true`)
			.then(res => res.json());
	}

	// * [->] 12.4.1 Создадим метод сортировки. Снова перейдём в документацию JSON-Server и посмотрим, что нам нужно дописать в URL для сортировки. А она предполагает добавление двух параметров "_sort" (параметр по которому идёт сортировка) и "_order" (на увеличение или уменьшение будет идти сортировка "desc" & "asc").
	// 12.4.2 А передавать аргументами будем объект
	// todo 12.4.3 переход в [sort-users.js][->]
	getSortUsers(sortOption) {
		return fetch(`http://localhost:3333/users?_sort=${sortOption}`)
			.then(res => res.json());
	}
	// ! К сожалению функция поиска в таком виде ('name_like=${str}') не работает и нужно найти как её сделать рабочей
	getSearchUsers(str) {
		return fetch(`http://localhost:3333/users?name_like=${str}`)
			.then(res => res.json());
	}
}