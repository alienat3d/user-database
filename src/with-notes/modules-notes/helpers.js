// * 14.5 debounce будет принимать аргументами функцию и кол-во миллисекунд — время задержки, которое скрипт будет ожидать нашего следующего вводе, прежде, чем послать запрос на сервер.
// 14.6 Итак мы передаём в debounce функцию и вернём эту функцию, привязав контекст вызова, все аргументы и тут же её вызовем.
export const debounce = (func, delay = 700) => {
	let timer;
	// 14.7 Также она будет возвращать стрелочную функцию, которая будет принимать все аргументы, а далее эта функция через метод apply(), которая привязывает контекст вызова, привяжет контекст через this и передаст все аргументы прошлой функции.
	// 14.8 Ну и применим задержку через setTimeout().
	// 14.9 И нам также надо будет записать нашу функцию setTimeout в переменную, чтобы её очищать при каждом новом запуске. Теперь у нас будет срабатывать запрос лишь 1 раз, когда пройдёт время "delay" с последнего события. Таким образом мы экономим ресурсы сервера, посылая запросы, только когда пользователь остановится или сделает паузу, а не каждую букву.
	return (...args) => {
		clearTimeout(timer);

		timer = setTimeout(() => { func.apply(this, args) }, delay);
	}
}